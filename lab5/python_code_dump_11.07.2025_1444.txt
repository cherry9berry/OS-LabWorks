=========================================
PYTHON CODE DUMP
Generated: 11.07.2025 14:44:26,85
Directory: D:\Users\chernousov-am\spo\lab5
=========================================


###############################################
### PROJECT STRUCTURE
###############################################

=== PROJECT STRUCTURE ===
dumper.bat
main_vfs.py
python_code_dump_11.07.2025_1444.txt
vfs_commands.py
vfs_core.py
vfs_manager.py
__pycache__
.git\config
.git\description
.git\HEAD
.git\hooks
.git\info
.git\objects
.git\refs
.git\hooks\applypatch-msg.sample
.git\hooks\commit-msg.sample
.git\hooks\fsmonitor-watchman.sample
.git\hooks\post-update.sample
.git\hooks\pre-applypatch.sample
.git\hooks\pre-commit.sample
.git\hooks\pre-merge-commit.sample
.git\hooks\pre-push.sample
.git\hooks\pre-rebase.sample
.git\hooks\pre-receive.sample
.git\hooks\prepare-commit-msg.sample
.git\hooks\update.sample
.git\info\exclude
.git\objects\info
.git\objects\pack
.git\refs\heads
.git\refs\tags
__pycache__\vfs_commands.cpython-311.pyc
__pycache__\vfs_core.cpython-311.pyc
__pycache__\vfs_manager.cpython-311.pyc


###############################################
### PYTHON FILES CONTENT
###############################################


=============================================
FILE: D:\Users\chernousov-am\spo\lab5\main_vfs.py
=============================================
Lines: 0

#!/usr/bin/env python3
"""
Основные команды:
- CD [path] - сменить директорию
- DIR - показать содержимое
- MKDIR <name> - создать директорию
- MKFILE <name> - создать файл
- MOUNT <source> <target> - смонтировать реальную директорию
- UMOUNT <path> - размонтировать
- RENAME <old> <new> - переименовать файл
- DEL <file> - удалить файл
- COPY <file> <path> - копировать файл
- SAVE <filename> - сохранить состояние
- LOAD <filename> - загрузить состояние
"""

import sys
import os
from vfs_manager import VFSManager, VFSDebugger
from vfs_commands import CommandParser


def main():
    print(__doc__)
    
    # creating vfc client
    manager = VFSManager("root")
    
    # commands handler
    if len(sys.argv) > 1:
        command = sys.argv[1].lower()
        
        if command in ['--help', '-h', 'help']:
            print(CommandParser.get_help())
            return
        elif command == '--debug':
            print("=== Режим отладки ===")
            VFSDebugger.show_vfs_info(manager)
            print("Переход в интерактивный режим...\n")
        elif command == '--load' and len(sys.argv) > 2:
            filename = sys.argv[2]
            if os.path.exists(filename):
                if manager.vfs.load_from_file(filename):
                    print(f"Состояние загружено из '{filename}'")
                else:
                    print(f"Ошибка при загрузке из '{filename}'")
            else:
                print(f"Файл '{filename}' не найден")
        elif command == '--test':
            run_tests(manager)
            return
    
    # Запуск интерактивного режима
    try:
        manager.run()
    except Exception as e:
        print(f"Критическая ошибка: {e}")
        sys.exit(1)


def run_tests(manager):
    """Запустить базовые тесты."""
    print("=== Запуск тестов VFS ===")
    
    test_cases = [
        ("MKDIR test1", "Создание директории", lambda: manager.vfs.root.name_exists("test1", "root")),
        ("MKDIR test2", "Создание второй директории", lambda: manager.vfs.root.name_exists("test2", "root")),
        ("CD test1", "Переход в директорию", lambda: manager.vfs.get_current_path() == "root/test1"),
        ("MKFILE file1.txt", "Создание файла", lambda: manager.vfs.root.find_node("root/test1").name_exists("file1.txt", "root/test1")),
        ("MKFILE file2.txt", "Создание второго файла", lambda: manager.vfs.root.find_node("root/test1").name_exists("file2.txt", "root/test1")),
        ("DIR", "Просмотр содержимого", lambda: len(manager.vfs.list_directory()) == 2),
        ("CD ..", "Возврат в родительскую директорию", lambda: manager.vfs.get_current_path() == "root"),
        ("COPY test1/file1.txt test2", "Копирование файла", lambda: manager.vfs.root.find_node("root/test2").name_exists("file1.txt", "root/test2")),
        ("RENAME test1/file2.txt renamed.txt", "Переименование файла", lambda: manager.vfs.root.find_node("root/test1").name_exists("renamed.txt", "root/test1") and not manager.vfs.root.find_node("root/test1").name_exists("file2.txt", "root/test1")),
        ("DEL test1/renamed.txt", "Удаление файла", lambda: not manager.vfs.root.find_node("root/test1").name_exists("renamed.txt", "root/test1")),
        ("SAVE test_state.json", "Сохранение состояния", lambda: os.path.exists("test_state.json")),
    ]
    
    success_count = 0
    total_count = len(test_cases)
    
    for command_str, description, check_func in test_cases:
        print(f"\n[ТЕСТ] {description}: {command_str}")
        
        command = CommandParser.parse(command_str)
        if command:
            try:
                manager.execute_command(command)
                if check_func():
                    success_count += 1
                    print("✓ УСПЕХ")
                else:
                    print("✗ ОШИБКА: Операция не выполнена корректно")
            except Exception as e:
                print(f"✗ ОШИБКА: {e}")
        else:
            print("✗ ОШИБКА: Неверная команда")
    
    print(f"\n=== Результаты тестов ===")
    print(f"Успешно: {success_count}/{total_count}")
    
    if success_count == total_count:
        print("Все тесты прошли успешно! ✓")
    else:
        print(f"Некоторые тесты не прошли: {total_count - success_count} ошибок")
    
    # Показать итоговое состояние
    print("\n=== Итоговое состояние VFS ===")
    VFSDebugger.show_vfs_info(manager)


if __name__ == "__main__":
    main()



=============================================
FILE: D:\Users\chernousov-am\spo\lab5\vfs_commands.py
=============================================
Lines: 0

from typing import List, Optional, Tuple


class Command:
    """Класс для представления команды с аргументами."""
    
    def __init__(self, command: str, *args: str):
        self.command = command.upper()
        self.args = list(args)
        
    def __repr__(self):
        return f"Command({self.command}, {self.args})"


class CommandParser:
    """Парсер команд для VFS."""
    
    VALID_COMMANDS = {
        'CD', 'DIR', 'MKDIR', 'MKFILE', 'MOUNT', 'UMOUNT', 'SAVE', 'LOAD', 'RENAME', 'DEL', 'COPY'
    }
    
    @staticmethod
    def parse(input_command: str) -> Optional[Command]:
        """
        Парсит введённую команду и возвращает объект Command.
        
        Args:
            input_command: Строка с командой
            
        Returns:
            Command или None в случае ошибки
        """
        input_command = input_command.strip()
        if not input_command:
            return None
            
        parts = input_command.split()
        if not parts:
            return None
            
        command = parts[0].upper()
        args = parts[1:]
        
        # Нормализация команд
        if command == "LS":
            command = "DIR"
            
        # Проверка валидности команды
        if command not in CommandParser.VALID_COMMANDS:
            return None
            
        # Валидация количества аргументов
        if not CommandParser._validate_args(command, args):
            return None
            
        return Command(command, *args)
    
    @staticmethod
    def _validate_args(command: str, args: List[str]) -> bool:
        """Проверить правильность количества аргументов для команды."""
        arg_requirements = {
            'CD': (0, 1),      # 0 или 1 аргумент
            'DIR': (0, 0),     # без аргументов
            'MKDIR': (1, 1),   # 1 аргумент
            'MKFILE': (1, 1),  # 1 аргумент
            'MOUNT': (2, 2),   # 2 аргумента
            'UMOUNT': (1, 1),  # 1 аргумент
            'SAVE': (1, 1),    # 1 аргумент
            'LOAD': (1, 1),    # 1 аргумент
            'RENAME': (2, 2),  # 2 аргумента
            'DEL': (1, 1),     # 1 аргумент
            'COPY': (2, 2),    # 2 аргумента
        }
        
        if command not in arg_requirements:
            return False
            
        min_args, max_args = arg_requirements[command]
        return min_args <= len(args) <= max_args
    
    @staticmethod
    def get_help() -> str:
        """Получить справку по командам."""
        help_text = """
Доступные команды:

Навигация:
  CD [path]           - Сменить директорию (без аргумента - в родительскую)
  DIR                 - Показать содержимое текущей директории

Создание:
  MKDIR <name>        - Создать директорию
  MKFILE <name>       - Создать файл

Монтирование:
  MOUNT <source> <target> - Смонтировать реальную директорию
  UMOUNT <path>       - Размонтировать директорию

Работа с файлами (Вариант 1):
  RENAME <old> <new>  - Переименовать файл
  DEL <file>          - Удалить файл
  COPY <file> <path>  - Копировать файл в директорию

Сохранение:
  SAVE <filename>     - Сохранить состояние VFS в файл
  LOAD <filename>     - Загрузить состояние VFS из файла
        """
        return help_text.strip()


def parse_command(input_str: str) -> Optional[Command]:
    """
    Удобная функция для парсинга команды.
    
    Args:
        input_str: Строка с командой
        
    Returns:
        Command или None
    """
    return CommandParser.parse(input_str)



=============================================
FILE: D:\Users\chernousov-am\spo\lab5\vfs_core.py
=============================================
Lines: 0

import os
import json
from typing import List, Optional, Dict, Any


class VFSNode:
    """
    Базовый класс для узлов виртуальной файловой системы (файлы и директории).
    """
    
    def __init__(self, name: str, is_dir: bool = True):
        self.name = name
        self.is_dir = is_dir
        self.children: List['VFSNode'] = []
        self.full_path = name
        self._content = ""  # Для файлов
        
    def update_full_path(self, parent_path: str = "") -> None:
        """Обновляет полный путь для узла и всех дочерних элементов."""
        if parent_path:
            self.full_path = f"{parent_path}/{self.name}"
        else:
            self.full_path = self.name
            
        for child in self.children:
            if child.is_dir:
                child.update_full_path(self.full_path)
                
    def find_node(self, path: str) -> Optional['VFSNode']:
        """Найти узел по пути."""
        path = path.lower().strip('/')
        if not path:
            path = 'root'
            
        if self.full_path.lower() == path:
            return self
            
        for child in self.children:
            if child.is_dir:
                result = child.find_node(path)
                if result:
                    return result
        return None
        
    def get_children_list(self, path: str = "") -> Optional[List['VFSNode']]:
        """Получить список дочерних элементов по пути."""
        if not path:
            return self.children
            
        target_node = self.find_node(path)
        return target_node.children if target_node and target_node.is_dir else None
        
    def name_exists(self, name: str, parent_path: str = "") -> bool:
        """Проверить существование имени в родительской директории."""
        parent_path = parent_path.lower().strip('/') or 'root'
        name = name.lower()
        
        if self.full_path.lower() == parent_path:
            return any(child.name.lower() == name for child in self.children)
            
        for child in self.children:
            if child.is_dir and child.name_exists(name, parent_path):
                return True
        return False
        
    def add_child(self, name: str, is_dir: bool = True, content: str = "") -> bool:
        """Добавить дочерний элемент."""
        if name.lower() == 'root':
            return False
            
        if any(child.name.lower() == name.lower() for child in self.children):
            return False
            
        new_node = VFSNode(name, is_dir)
        if not is_dir:
            new_node._content = content
        new_node.update_full_path(self.full_path)
        self.children.append(new_node)
        return True
        
    def remove_child(self, name: str) -> bool:
        """Удалить дочерний элемент."""
        name = name.lower()
        for i, child in enumerate(self.children):
            if child.name.lower() == name:
                del self.children[i]
                return True
        return False
        
    def rename_file(self, old_name: str, new_name: str) -> bool:
        """Переименовать файл."""
        if new_name.lower() == 'root':
            return False
            
        old_name = old_name.lower()
        
        if any(child.name.lower() == new_name.lower() for child in self.children):
            return False
            
        for child in self.children:
            if child.name.lower() == old_name and not child.is_dir:
                child.name = new_name
                child.full_path = f"{self.full_path}/{new_name}"
                return True
        return False
        
    def delete_file(self, name: str) -> bool:
        """Удалить файл."""
        name = name.lower()
        for i, child in enumerate(self.children):
            if child.name.lower() == name and not child.is_dir:
                del self.children[i]
                return True
        return False
        
    def copy_file(self, file_name: str, target_path: str, root_node: 'VFSNode') -> bool:
        """Копировать файл в другую директорию."""
        file_name = file_name.lower()
        
        source_file = None
        for child in self.children:
            if child.name.lower() == file_name and not child.is_dir:
                source_file = child
                break
                
        if not source_file:
            return False
            
        target_node = root_node.find_node(target_path)
        if not target_node or not target_node.is_dir:
            return False
            
        if target_node.name_exists(source_file.name, target_node.full_path):
            return False
            
        return target_node.add_child(source_file.name, False, source_file._content)
        
    def delete_directory(self, name: str) -> bool:
        """Удалить директорию."""
        name = name.lower()
        for i, child in enumerate(self.children):
            if child.name.lower() == name and child.is_dir:
                del self.children[i]
                return True
        return False
        
    def mount_real_directory(self, source: str, target_name: str) -> bool:
        """Смонтировать реальную директорию."""
        if target_name.lower() == 'root':
            return False
            
        if not os.path.exists(source) or not os.path.isdir(source):
            return False
            
        if self.name_exists(target_name, self.full_path):
            return False
            
        mounted_dir = VFSNode(target_name, True)
        mounted_dir.update_full_path(self.full_path)
        self.children.append(mounted_dir)
        
        try:
            self._mount_recursive(source, mounted_dir)
            return True
        except Exception:
            self.remove_child(target_name)
            return False
            
    def _mount_recursive(self, source_path: str, target_node: 'VFSNode') -> None:
        """Рекурсивное монтирование директории."""
        try:
            for item in os.listdir(source_path):
                if item.lower() == 'root':
                    continue
                    
                item_path = os.path.join(source_path, item)
                
                if os.path.isdir(item_path):
                    if target_node.add_child(item, True):
                        child_dir = next(
                            child for child in target_node.children 
                            if child.name.lower() == item.lower() and child.is_dir
                        )
                        self._mount_recursive(item_path, child_dir)
                else:
                    target_node.add_child(item, False, f"[Mounted file: {item_path}]")
                    
        except (PermissionError, OSError):
            pass
            
    def to_dict(self) -> Dict[str, Any]:
        """Преобразовать в словарь для сериализации."""
        return {
            "name": self.name,
            "is_dir": self.is_dir,
            "content": self._content if not self.is_dir else "",
            "children": [child.to_dict() for child in self.children]
        }
        
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'VFSNode':
        """Создать узел из словаря."""
        node = cls(data["name"], data["is_dir"])
        if not node.is_dir:
            node._content = data.get("content", "")
            
        for child_data in data.get("children", []):
            child = cls.from_dict(child_data)
            node.children.append(child)
            
        return node
        
    def get_content(self) -> str:
        """Получить содержимое файла."""
        return self._content if not self.is_dir else ""
        
    def set_content(self, content: str) -> None:
        """Установить содержимое файла."""
        if not self.is_dir:
            self._content = content


class VirtualFileSystem:
    """
    Основной класс виртуальной файловой системы.
    """
    
    def __init__(self, root_name: str = "root"):
        self.root = VFSNode(root_name, True)
        self.current_directory = [root_name]
        
    def get_current_path(self) -> str:
        """Получить текущий путь."""
        return "/".join(self.current_directory)
        
    def resolve_path(self, path: str) -> Optional[str]:
        """Разрешить путь относительно текущей директории."""
        if not path:
            return self.get_current_path()
            
        path = path.strip('/')
        if not path:
            return 'root'
            
        current = self.current_directory[:]
        
        if path.startswith('root'):
            current = ['root']
            path = path[5:] if path.startswith('root/') else path[4:]
        elif path.startswith('/'):
            current = ['root']
            path = path[1:] if path else ''
            
        if path:
            parts = path.split('/')
            for part in parts:
                if part == '..':
                    if len(current) > 1:
                        current.pop()
                elif part and part != '.':
                    full_path = '/'.join(current + [part]).lower()
                    if self.root.find_node(full_path):
                        current.append(part)
                    else:
                        return None
                        
        return '/'.join(current) if current else 'root'
        
    def change_directory(self, path: str = None) -> bool:
        """Сменить текущую директорию."""
        if path:
            resolved = self.resolve_path(path)
            if resolved:
                self.current_directory = resolved.split('/')
                return True
            return False
        else:
            if len(self.current_directory) > 1:
                self.current_directory.pop()
                return True
            return False
            
    def create_directory(self, name: str) -> bool:
        """Создать директорию в текущем местоположении."""
        if not name:
            return False
            
        current_path = self.get_current_path()
        current_node = self.root.find_node(current_path)
        
        if current_node and current_node.is_dir:
            return current_node.add_child(name, True)
        return False
        
    def create_file(self, name: str, content: str = "") -> bool:
        """Создать файл в текущем местоположении."""
        if not name:
            return False
            
        current_path = self.get_current_path()
        current_node = self.root.find_node(current_path)
        
        if current_node and current_node.is_dir:
            return current_node.add_child(name, False, content)
        return False
        
    def list_directory(self) -> List[VFSNode]:
        """Получить содержимое текущей директории."""
        current_path = self.get_current_path()
        current_node = self.root.find_node(current_path)
        
        if current_node and current_node.is_dir:
            return current_node.children
        return []
        
    def mount_directory(self, source: str, target: str) -> bool:
        """Смонтировать реальную директорию."""
        target = target.strip('/')
        target_name = target.split('/')[-1]
        
        if len(target.split('/')) > 1:
            target_parent = '/'.join(target.split('/')[:-1])
            resolved_parent = self.resolve_path(target_parent)
        else:
            resolved_parent = self.get_current_path()
            
        if not resolved_parent:
            return False
            
        parent_node = self.root.find_node(resolved_parent)
        if parent_node and parent_node.is_dir:
            return parent_node.mount_real_directory(source, target_name)
        return False
        
    def unmount_directory(self, dir_name: str) -> bool:
        """Размонтировать (удалить) директорию."""
        if not dir_name:
            return False
            
        current_path = self.get_current_path()
        current_node = self.root.find_node(current_path)
        
        if current_node and current_node.is_dir:
            return current_node.delete_directory(dir_name)
        return False
        
    def rename_file(self, old_name: str, new_name: str) -> bool:
        """Переименовать файл."""
        old_path = self.resolve_path(old_name)
        if not old_path:
            return False
            
        parent_path = '/'.join(old_path.split('/')[:-1]) or 'root'
        old_file_name = old_path.split('/')[-1]
        parent_node = self.root.find_node(parent_path)
        
        if parent_node and parent_node.is_dir:
            return parent_node.rename_file(old_file_name, new_name)
        return False
        
    def delete_file(self, name: str) -> bool:
        """Удалить файл."""
        file_path = self.resolve_path(name)
        if not file_path:
            return False
            
        parent_path = '/'.join(file_path.split('/')[:-1]) or 'root'
        file_name = file_path.split('/')[-1]
        parent_node = self.root.find_node(parent_path)
        
        if parent_node and parent_node.is_dir:
            return parent_node.delete_file(file_name)
        return False
        
    def copy_file(self, file_name: str, target_path: str) -> bool:
        """Копировать файл."""
        file_path = self.resolve_path(file_name)
        if not file_path:
            return False
            
        resolved_target = self.resolve_path(target_path)
        if not resolved_target:
            return False
            
        parent_path = '/'.join(file_path.split('/')[:-1]) or 'root'
        source_file_name = file_path.split('/')[-1]
        parent_node = self.root.find_node(parent_path)
        
        if parent_node and parent_node.is_dir:
            return parent_node.copy_file(source_file_name, resolved_target, self.root)
        return False
        
    def save_to_file(self, filename: str) -> bool:
        """Сохранить VFS в файл."""
        try:
            data = {
                "root": self.root.to_dict(),
                "current_directory": self.current_directory
            }
            with open(filename, "w", encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
            return True
        except Exception:
            return False
            
    def load_from_file(self, filename: str) -> bool:
        """Загрузить VFS из файла."""
        if not os.path.exists(filename):
            return False
            
        try:
            with open(filename, "r", encoding='utf-8') as f:
                data = json.load(f)
                
            self.root = VFSNode.from_dict(data["root"])
            self.root.update_full_path("")
            self.current_directory = data.get("current_directory", [self.root.name])
            
            current_path = self.get_current_path()
            if not self.root.find_node(current_path):
                self.current_directory = [self.root.name]
                
            return True
        except Exception:
            return False



=============================================
FILE: D:\Users\chernousov-am\spo\lab5\vfs_manager.py
=============================================
Lines: 0

from typing import Optional
from vfs_core import VirtualFileSystem
from vfs_commands import Command, CommandParser


class VFSManager:
    """
    Менеджер виртуальной файловой системы.
    Обрабатывает команды и управляет состоянием.
    """
    
    def __init__(self, root_name: str = "root"):
        self.vfs = VirtualFileSystem(root_name)
        self.is_running = True
        
    def execute_command(self, command: Command) -> None:
        """Выполнить команду."""
        if not command:
            return
            
        try:
            method_name = f"_cmd_{command.command.lower()}"
            if hasattr(self, method_name):
                method = getattr(self, method_name)
                method(command.args)
            else:
                print(f"Ошибка: Неизвестная команда '{command.command}'")
        except Exception as e:
            print(f"Ошибка выполнения команды: {e}")
            
    def _cmd_cd(self, args) -> None:
        """Выполнить команду CD."""
        path = args[0] if args else None
        if self.vfs.change_directory(path):
            if path:
                print(f"Переход в директорию: {path}")
        else:
            if path:
                print(f"Ошибка: Директория '{path}' не найдена")
            else:
                print("Ошибка: Нельзя подняться выше корневой директории")
        print()
        
    def _cmd_dir(self, args) -> None:
        """Выполнить команду DIR."""
        print("Содержимое текущей директории:")
        children = self.vfs.list_directory()
        
        if not children:
            print("  (пусто)")
        else:
            for child in children:
                if child.is_dir:
                    print(f"  [{child.name}]/")
                else:
                    print(f"  {child.name}")
        print()
        
    def _cmd_mkdir(self, args) -> None:
        """Выполнить команду MKDIR."""
        if not args:
            print("Ошибка: Укажите имя директории")
            print()
            return
            
        dir_name = args[0]
        if self.vfs.create_directory(dir_name):
            print(f"Директория '{dir_name}' создана")
        else:
            print(f"Ошибка: Не удалось создать директорию '{dir_name}'")
        print()
        
    def _cmd_mkfile(self, args) -> None:
        """Выполнить команду MKFILE."""
        if not args:
            print("Ошибка: Укажите имя файла")
            print()
            return
            
        file_name = args[0]
        if self.vfs.create_file(file_name):
            print(f"Файл '{file_name}' создан")
        else:
            print(f"Ошибка: Не удалось создать файл '{file_name}'")
        print()
        
    def _cmd_mount(self, args) -> None:
        """Выполнить команду MOUNT."""
        if len(args) < 2:
            print("Ошибка: Укажите source и target")
            print()
            return
            
        source, target = args
        if self.vfs.mount_directory(source, target):
            print(f"Директория '{source}' смонтирована как '{target}'")
        else:
            print(f"Ошибка при монтировании '{source}' в '{target}'")
        print()
        
    def _cmd_umount(self, args) -> None:
        """Выполнить команду UMOUNT."""
        if not args:
            print("Ошибка: Укажите путь для размонтирования")
            print()
            return
            
        path = args[0]
        if self.vfs.unmount_directory(path):
            print(f"Директория '{path}' размонтирована")
        else:
            print(f"Ошибка: Директория '{path}' не найдена")
        print()
        
    def _cmd_rename(self, args) -> None:
        """Выполнить команду RENAME."""
        if len(args) < 2:
            print("Ошибка: Укажите старое и новое имя файла")
            print()
            return
            
        old_name, new_name = args
        old_path = self.vfs.resolve_path(old_name)
        if not old_path:
            print(f"Ошибка: Файл '{old_name}' не найден")
            print()
            return
            
        parent_path = '/'.join(old_path.split('/')[:-1]) or 'root'
        old_file_name = old_path.split('/')[-1]
        parent_node = self.vfs.root.find_node(parent_path)
        
        if parent_node and parent_node.rename_file(old_file_name, new_name):
            print(f"Файл переименован: '{old_name}' -> '{new_name}'")
        else:
            print(f"Ошибка: Не удалось переименовать файл '{old_name}'")
        print()
        
    def _cmd_del(self, args) -> None:
        """Выполнить команду DEL."""
        if not args:
            print("Ошибка: Укажите имя файла")
            print()
            return
            
        file_name = args[0]
        file_path = self.vfs.resolve_path(file_name)
        if not file_path:
            print(f"Ошибка: Файл '{file_name}' не найден")
            print()
            return
            
        parent_path = '/'.join(file_path.split('/')[:-1]) or 'root'
        file_name = file_path.split('/')[-1]
        parent_node = self.vfs.root.find_node(parent_path)
        
        if parent_node and parent_node.delete_file(file_name):
            print(f"Файл '{file_name}' удален")
        else:
            print(f"Ошибка: Файл '{file_name}' не найден")
        print()
        
    def _cmd_copy(self, args) -> None:
        """Выполнить команду COPY."""
        if len(args) < 2:
            print("Ошибка: Укажите имя файла и целевой путь")
            print()
            return
            
        file_name, target_path = args
        file_path = self.vfs.resolve_path(file_name)
        if not file_path:
            print(f"Ошибка: Файл '{file_name}' не найден")
            print()
            return
            
        resolved_target = self.vfs.resolve_path(target_path)
        if not resolved_target:
            print(f"Ошибка: Целевой путь '{target_path}' не найден")
            print()
            return
            
        parent_path = '/'.join(file_path.split('/')[:-1]) or 'root'
        source_file_name = file_path.split('/')[-1]
        parent_node = self.vfs.root.find_node(parent_path)
        
        if parent_node and parent_node.copy_file(source_file_name, resolved_target, self.vfs.root):
            print(f"Файл '{file_name}' скопирован в '{target_path}'")
        else:
            print(f"Ошибка: Не удалось скопировать файл '{file_name}' в '{target_path}'")
        print()
        
    def _cmd_save(self, args) -> None:
        """Выполнить команду SAVE."""
        if not args:
            print("Ошибка: Укажите имя файла")
            print()
            return
            
        filename = args[0]
        if self.vfs.save_to_file(filename):
            print(f"Состояние VFS сохранено в '{filename}'")
        else:
            print(f"Ошибка при сохранении в '{filename}'")
        print()
        
    def _cmd_load(self, args) -> None:
        """Выполнить команду LOAD."""
        if not args:
            print("Ошибка: Укажите имя файла")
            print()
            return
            
        filename = args[0]
        if self.vfs.load_from_file(filename):
            print(f"Состояние VFS загружено из '{filename}'")
        else:
            print(f"Ошибка при загрузке из '{filename}'")
        print()
        
    def get_prompt(self) -> str:
        """Получить строку приглашения."""
        return f"VFS:{self.vfs.get_current_path()}> "
        
    def run(self) -> None:
        print()
        
        try:
            while self.is_running:
                try:
                    user_input = input(self.get_prompt()).strip()
                    
                    if not user_input:
                        continue
                        
                    if user_input.lower() in ['help', '?', '--help', '-h']:
                        print(CommandParser.get_help())
                        print()
                        continue
                        
                    command = CommandParser.parse(user_input)
                    if command:
                        self.execute_command(command)
                    else:
                        print("Ошибка: Неверная команда или количество аргументов")
                        print("Введите 'help' для получения справки")
                        print()
                        
                except EOFError:
                    break

                    
        except Exception as e:
            print(f"Критическая ошибка: {e}")
        finally:
            print("\nВыход из VFS")


class VFSDebugger:
    """Утилиты для отладки VFS."""
    
    @staticmethod
    def print_tree(node, level=0):
        """Вывести дерево файловой системы."""
        indent = "  " * level
        marker = "[D]" if node.is_dir else "[F]"
        print(f"{indent}{marker} {node.name}")
        
        if node.is_dir:
            for child in node.children:
                VFSDebugger.print_tree(child, level + 1)
    
    @staticmethod
    def show_vfs_info(vfs_manager):
        """Показать информацию о состоянии VFS."""
        vfs = vfs_manager.vfs
        print("=== Информация о VFS ===")
        print(f"Текущий путь: {vfs.get_current_path()}")
        print(f"Корневая директория: {vfs.root.name}")
        print("\nСтруктура файловой системы:")
        VFSDebugger.print_tree(vfs.root)
        print()


class VFSValidator:
    """Валидатор для проверки целостности VFS."""
    
    @staticmethod
    def validate_paths(node, expected_path=""):
        """Проверить корректность путей в дереве."""
        errors = []
        
        if expected_path and node.full_path != expected_path:
            errors.append(f"Неверный путь узла '{node.name}': ожидался '{expected_path}', получен '{node.full_path}'")
        
        for child in node.children:
            child_expected_path = f"{node.full_path}/{child.name}" if node.full_path != child.name else child.name
            child_errors = VFSValidator.validate_paths(child, child_expected_path)
            errors.extend(child_errors)
            
        return errors
    
    @staticmethod
    def check_name_conflicts(node):
        """Проверить конфликты имен в директории."""
        errors = []
        
        if node.is_dir:
            names = [child.name.lower() for child in node.children]
            if len(names) != len(set(names)):
                errors.append(f"Конфликт имен в директории '{node.full_path}'")
        
        for child in node.children:
            if child.is_dir:
                child_errors = VFSValidator.check_name_conflicts(child)
                errors.extend(child_errors)
                
        return errors



=============================================
FILE: dumper.bat
=============================================
Lines: 0

@echo off
chcp 65001 >nul
setlocal enabledelayedexpansion

:: Dump Python Code - Создание дампа всех Python файлов
:: Автор: Vacation Tool Project
:: Версия: 1.5 (исправленная рабочая версия)

echo ========================================
echo   Dump Python Code v1.5
echo   Создание дампа всех Python файлов
echo ========================================
echo.

:: Получаем текущую дату и время для имени файла
for /f "tokens=1-3 delims=/ " %%a in ('date /t') do (
    set "current_date=%%c%%b%%a"
)
for /f "tokens=1-2 delims=: " %%a in ('time /t') do (
    set "current_time=%%a%%b"
)

:: Убираем точки и пробелы из времени
set "current_time=%current_time:.=%"
set "current_time=%current_time: =%"

:: Имя выходного файла
set "output_file=python_code_dump_%current_date%_%current_time%.txt"

echo Создание дампа: %output_file%
echo.

:: Счетчики
set /a file_count=0
set /a total_lines=0

:: Создаем файл с UTF-8 BOM
powershell -Command "[System.IO.File]::WriteAllText('%output_file%', '', (New-Object System.Text.UTF8Encoding $true))" >nul

:: Создаем заголовок через временный файл
echo =========================================> "%temp%\header.tmp"
echo PYTHON CODE DUMP>> "%temp%\header.tmp"
echo Generated: %date% %time%>> "%temp%\header.tmp"
echo Directory: %cd%>> "%temp%\header.tmp"
echo =========================================>> "%temp%\header.tmp"
echo.>> "%temp%\header.tmp"

powershell -Command "Get-Content '%temp%\header.tmp' -Encoding UTF8 | Out-File -FilePath '%output_file%' -Encoding UTF8 -Append"
del "%temp%\header.tmp" >nul

:: PROJECT STRUCTURE
echo.>> "%temp%\structure.tmp"
echo ###############################################>> "%temp%\structure.tmp"
echo ### PROJECT STRUCTURE>> "%temp%\structure.tmp"
echo ###############################################>> "%temp%\structure.tmp"
echo.>> "%temp%\structure.tmp"
echo === PROJECT STRUCTURE ===>> "%temp%\structure.tmp"

powershell -Command "Get-Content '%temp%\structure.tmp' -Encoding UTF8 | Out-File -FilePath '%output_file%' -Encoding UTF8 -Append"
del "%temp%\structure.tmp" >nul

:: Простое дерево
dir /s /b > "%temp%\tree.tmp"
powershell -Command "Get-Content '%temp%\tree.tmp' -Encoding UTF8 | ForEach-Object { $_.Replace('%cd%\', '') } | Out-File -FilePath '%output_file%' -Encoding UTF8 -Append"
del "%temp%\tree.tmp" >nul

:: Разделитель для файлов
echo.>> "%temp%\separator.tmp"
echo.>> "%temp%\separator.tmp"
echo ###############################################>> "%temp%\separator.tmp"
echo ### PYTHON FILES CONTENT>> "%temp%\separator.tmp"
echo ###############################################>> "%temp%\separator.tmp"
echo.>> "%temp%\separator.tmp"

powershell -Command "Get-Content '%temp%\separator.tmp' -Encoding UTF8 | Out-File -FilePath '%output_file%' -Encoding UTF8 -Append"
del "%temp%\separator.tmp" >nul

:: Обходим все Python файлы
echo Поиск Python файлов...
for /R %%f in (*.py) do (
    call :process_file "%%f"
)

:: Добавляем другие важные файлы
echo.
echo Поиск дополнительных файлов...

if exist "requirements.txt" call :process_text_file "requirements.txt"
if exist "README.md" call :process_text_file "README.md"
if exist "config.json" call :process_text_file "config.json"
if exist ".gitignore" call :process_text_file ".gitignore"

:: Любые .bat файлы (кроме текущего)
for %%f in (*.bat) do (
    if not "%%~nf"=="dump_python_code" (
        call :process_text_file "%%f"
    )
)

:: Статистика
echo.>> "%temp%\stats.tmp"
echo ###############################################>> "%temp%\stats.tmp"
echo ### STATISTICS>> "%temp%\stats.tmp"
echo ###############################################>> "%temp%\stats.tmp"
echo.>> "%temp%\stats.tmp"
echo === STATISTICS ===>> "%temp%\stats.tmp"
echo Total Python files processed: %file_count%>> "%temp%\stats.tmp"
echo Total lines of code: %total_lines%>> "%temp%\stats.tmp"
echo Dump created: %date% %time%>> "%temp%\stats.tmp"
echo =============================================>> "%temp%\stats.tmp"

powershell -Command "Get-Content '%temp%\stats.tmp' -Encoding UTF8 | Out-File -FilePath '%output_file%' -Encoding UTF8 -Append"
del "%temp%\stats.tmp" >nul

:: Итоговое сообщение
echo.
echo ========================================
echo Дамп создан успешно!
echo ========================================
echo Файл: %output_file%
echo Обработано файлов: %file_count%
echo Всего строк кода: %total_lines%
echo ========================================
echo.

:: Открываем папку с файлом
echo Открыть папку с дампом? (Y/N)
set /p "choice=Ваш выбор: "
if /i "%choice%"=="Y" explorer .

goto :end

:: Функция обработки файла
:process_file
set "filepath=%~1"
set "filename=%~nx1"
set "relative_path=%filepath:*%cd%\=%"

echo Обработка: %relative_path%

:: Подсчитываем строки
set /a current_lines=0
for /f %%i in ('find /c /v "" "%filepath%" 2^>nul') do set /a current_lines=%%i
if !current_lines! EQU 0 set /a current_lines=0
set /a total_lines+=current_lines

:: Создаем заголовок во временном файле
echo.> "%temp%\file_header.tmp"
echo =============================================>> "%temp%\file_header.tmp"
echo FILE: %relative_path%>> "%temp%\file_header.tmp"
echo =============================================>> "%temp%\file_header.tmp"
echo Lines: !current_lines!>> "%temp%\file_header.tmp"
echo.>> "%temp%\file_header.tmp"

:: Записываем заголовок
powershell -Command "Get-Content '%temp%\file_header.tmp' -Encoding UTF8 | Out-File -FilePath '%output_file%' -Encoding UTF8 -Append"

:: Записываем содержимое файла
powershell -Command "Get-Content '%filepath%' -Encoding UTF8 -ErrorAction SilentlyContinue | Out-File -FilePath '%output_file%' -Encoding UTF8 -Append"

:: Добавляем пустые строки
echo.>> "%temp%\empty.tmp"
echo.>> "%temp%\empty.tmp"
powershell -Command "Get-Content '%temp%\empty.tmp' -Encoding UTF8 | Out-File -FilePath '%output_file%' -Encoding UTF8 -Append"

:: Удаляем временные файлы
del "%temp%\file_header.tmp" >nul 2>&1
del "%temp%\empty.tmp" >nul 2>&1

set /a file_count+=1
goto :eof

:: Функция обработки текстовых файлов
:process_text_file
set "filepath=%~1"
set "filename=%~nx1"

echo Обработка: %filename%

:: Подсчитываем строки
set /a current_lines=0
for /f %%i in ('find /c /v "" "%filepath%" 2^>nul') do set /a current_lines=%%i
if !current_lines! EQU 0 set /a current_lines=0
set /a total_lines+=current_lines

:: Создаем заголовок во временном файле
echo.> "%temp%\text_header.tmp"
echo =============================================>> "%temp%\text_header.tmp"
echo FILE: %filename%>> "%temp%\text_header.tmp"
echo =============================================>> "%temp%\text_header.tmp"
echo Lines: !current_lines!>> "%temp%\text_header.tmp"
echo.>> "%temp%\text_header.tmp"

:: Записываем заголовок
powershell -Command "Get-Content '%temp%\text_header.tmp' -Encoding UTF8 | Out-File -FilePath '%output_file%' -Encoding UTF8 -Append"

:: Записываем содержимое файла
powershell -Command "Get-Content '%filepath%' -Encoding UTF8 -ErrorAction SilentlyContinue | Out-File -FilePath '%output_file%' -Encoding UTF8 -Append"

:: Добавляем пустые строки
echo.>> "%temp%\empty2.tmp"
echo.>> "%temp%\empty2.tmp"
powershell -Command "Get-Content '%temp%\empty2.tmp' -Encoding UTF8 | Out-File -FilePath '%output_file%' -Encoding UTF8 -Append"

:: Удаляем временные файлы
del "%temp%\text_header.tmp" >nul 2>&1
del "%temp%\empty2.tmp" >nul 2>&1

set /a file_count+=1
goto :eof

:end
echo Нажмите любую клавишу для выхода...
pause >nul



###############################################
### STATISTICS
###############################################

=== STATISTICS ===
Dump created: 11.07.2025 14:45:05,79
=============================================
